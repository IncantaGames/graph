<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>graph: graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">graph
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">graph </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/childsish/graph">![Build Status](https://travis-ci.org/childsish/graph.svg?branch=master)</a></p>
<p><em>graph</em> is a simple header library of basic C++ graph (as in networks, not plots) classes. A couple of basic classes are implemented that allow most other graph types to be simulated; <code>Graph</code> and <code>PartiteGraph</code>.</p>
<p><code>Graph</code> is a directed graph with only one edge per vertex pair and no edge weights. Vertices do not need to be predefined. Currently cyclic/acyclic behaviour needs to be enforced by the user.</p>
<p><code>PartiteGraph</code> is a subclass of <code>Graph</code> that splits vertices into separate partitions and prevents vertices from belonging to multiple partitions or edges among vertices from the same partition.</p>
<h2><code>Graph</code> example</h2>
<h3>Specifying type</h3>
<p>When declaring a <code>Graph</code>, the type of the vertex identifiers needs to be defined using the template parameter. Internally vertices are stored in an [<code>std::unordered_map</code>](1) and thus must follow the specifications outlined for [<code>UnorderedAssociativeContainers</code>](2).</p>
<p>```cpp #include &lt;string&gt; #include &lt;<a class="el" href="Graph_8h_source.html">graph/Graph.h</a>&gt;</p>
<p>graph::Graph&lt;int&gt; int_graph; graph::Graph&lt;std::String&gt; string_graph; ```</p>
<h3>Adding edges</h3>
<p>Edges are added using <code>Graph::add_edge</code>. Unlike the <code>PartiteGraph</code>, vertices will be created automatically if they don't already exist.</p>
<p>```cpp #include &lt;<a class="el" href="Graph_8h_source.html">graph/Graph.h</a>&gt;</p>
<p>graph::Graph&lt;int&gt; graph; graph.add_edge(0, 1); graph.add_edge(0, 2);</p>
<p>graph.get_children(0); // {0, 1} ```</p>
<h3>Querying neighbours</h3>
<p><code>Graph</code> has five methods for getting the various types of neighbours:</p>
<ul>
<li><code>Graph::get_children</code></li>
<li><code>Graph::get_parents</code></li>
<li><code>Graph::get_neightbours</code></li>
<li><code>Graph::get_descendents</code></li>
<li><code>Graph::get_ancestors</code></li>
</ul>
<p>```cpp #include &lt;string&gt; #include &lt;<a class="el" href="Graph_8h_source.html">graph/Graph.h</a>&gt;</p>
<p>graph::Graph&lt;std::string&gt; graph.add_edge("A", "B"); graph.add_edge("B", "C"); graph.add_edge("B", "D");</p>
<p>graph.get_children("B"); // {"C", "D"} graph.get_parents("B"); // {"A"} graph.get_neightbours("B"); // {"A", "C", "D"} graph.get_descendents("A"); // {"B", "C", "D"} graph.get_ancestors("C") // {"A", "B"} ```</p>
<h2><code>PartiteGraph</code> example</h2>
<h3>Specifying types</h3>
<p>When declaring a <code>PartiteGraph</code>, the type of the vertex identifiers and all partitions need to be defined.</p>
<p>```cpp #include &lt;<a class="el" href="PartiteGraph_8h_source.html">graph/PartiteGraph.h</a>&gt;</p>
<p>struct Vertex { std::string name; }; struct Edge { float weight; };</p>
<p>graph::PartiteGraph&lt;int, Vertex, Edge&gt; graph; ```</p>
<h3>Adding edges</h3>
<p>Edges are also added using <code>PartiteGraph::edge_edge</code>. However, unlike <code>Graph</code>, vertices are not created automatically and first need to be added using <code>PartiteGraph::add</code>. Additionally, an edge can not be created between two vertices from the same partition.</p>
<p>```cpp #include &lt;<a class="el" href="PartiteGraph_8h_source.html">graph/PartiteGraph.h</a>&gt;</p>
<p>enum Partition { vertex_partition, edge_partition }; struct Vertex { std::string name; }; struct Edge { float weight; };</p>
<p>// Add vertices graph::PartiteGraph&lt;int, Vertex, Edge&gt; graph; graph.add_vertex&lt;vertex_partition&gt;(0, {"A"}); graph.add_vertex&lt;vertex_partition&gt;(1, {"B"}); graph.add_vertex&lt;vertex_partition&gt;(2, {"C"}); graph.add_vertex&lt;vertex_partition&gt;(3, {"D"}); graph.add_vertex&lt;edge_partition&gt;(4, {1.0}); graph.add_vertex&lt;edge_partition&gt;(5, {0.5}); graph.add_vertex&lt;edge_partition&gt;(6, {0.0});</p>
<p>// Add edges graph.add_edge(0, 4); graph.add_edge(4, 1); graph.add_edge(1, 5); graph.add_edge(1, 6); graph.add_edge(5, 2); graph.add_edge(6, 3); ```</p>
<h2>Different graph types</h2>
<ul>
<li><b>Undirected graph.</b> Simply use <code>Graph::get_neighbours</code>.</li>
<li><b>Multigraph.</b> Use a <code>PartiteGraph</code> with two partitions. One partition is for vertex vertices and the other is for edge vertices. This will allow vertices in the vertex partition to be connected with each other via vertices in the edge partition. A subclass could be used to simplify getting neighbours. See example <a href="#adding-edges-1">Adding edges</a>.</li>
<li><b>Edge weights.</b> Use a <code>PartiteGraph</code> and add edge weights to one of the partition types. Also see example <a href="#adding-edges-1">Adding edges</a>. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
